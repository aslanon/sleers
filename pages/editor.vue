<template>
	<div
		class="w-full !select-none flex flex-col bg-black text-white h-screen overflow-hidden"
	>
		<div
			class="editor-header w-full p-3 px-6 pl-24 bg-black border-b border-gray-700 flex justify-between gap-2 flex-shrink-0"
			:class="{ 'cursor-grab': !isDragging, 'cursor-grabbing': isDragging }"
			@mousedown="startDrag"
		>
			<button
				class="btn-new-record flex flex-row gap-2 items-center"
				@click="startNewRecording()"
			>
				<svg
					xmlns="http://www.w3.org/2000/svg"
					class="h-5 w-5"
					viewBox="0 0 24 24"
					fill="none"
					stroke="currentColor"
				>
					<path
						stroke-linecap="round"
						stroke-linejoin="round"
						stroke-width="2"
						d="M12 9v6m3-3H9m12 0a9 9 0 11-18 0 9 9 0 0118 0z"
					/>
				</svg>
				Yeni Kayıt
			</button>

			<!-- Butonlar -->
			<div class="flex flex-row gap-2 items-center">
				<button
					class="btn-export flex flex-row gap-2 items-center"
					@click="saveVideo()"
				>
					<svg
						xmlns="http://www.w3.org/2000/svg"
						class="h-5 w-5"
						viewBox="0 0 24 24"
						fill="none"
						stroke="currentColor"
					>
						<path
							stroke-linecap="round"
							stroke-linejoin="round"
							stroke-width="2"
							d="M4 16v1a3 3 0 003 3h10a3 3 0 003-3v-1m-4-8l-4-4m0 0L8 8m4-4v12"
						/>
					</svg>
					Kaydet
				</button>

				<!-- <button
					class="px-4 py-2 bg-gray-700 hover:bg-gray-600 rounded-lg"
					@click="discardChanges()"
				>
					Kapat
				</button> -->
			</div>
		</div>
		<!-- Ana İçerik -->
		<div class="flex-1 flex flex-col min-h-0">
			<div class="w-full flex flex-1">
				<div class="flex-shrink-0 w-[500px] h-full flex flex-col">
					<div class="flex-1 p-4 relative">
						<MediaPlayerSettings
							:duration="videoDuration"
							:width="videoWidth"
							:height="videoHeight"
							v-model="mouseSize"
							:media-player="mediaPlayerRef"
							class="relative"
						/>
					</div>
				</div>
				<div class="w-full p-4 flex-1 flex flex-col">
					<div
						class="flex-1 relative min-h-0 m-auto"
						style="
							width: 800px;
							height: 600px;
							min-width: 800px;
							min-height: 600px;
						"
					>
						<MediaPlayer
							ref="mediaPlayerRef"
							:video-url="videoUrl"
							:audio-url="audioUrl"
							:camera-url="cameraUrl"
							:video-type="videoType"
							:audio-type="audioType"
							:camera-type="cameraType"
							:is-playing="isPlaying"
							:current-time="currentTime"
							:preview-time="previewTime"
							:is-muted="isMuted"
							:segments="segments"
							:mouse-positions="mousePositions"
							:mouse-size="mouseSize"
							:is-crop-mode="isCropMode"
							@video-loaded="onVideoLoaded"
							@video-ended="onVideoEnded"
							@video-paused="isPlaying = false"
							@timeUpdate="onTimeUpdate"
							@mute-change="isMuted = $event"
							@update:isCropMode="isCropMode = $event"
							class="absolute inset-0 h-full"
						/>
					</div>
					<MediaPlayerControls
						:is-playing="isPlaying"
						:current-time="currentTime"
						:preview-time="previewTime"
						:duration="videoDuration"
						:is-trim-mode="isTrimMode"
						:selected-ratio="selectedRatio"
						:is-muted="isMuted"
						:is-split-mode="isSplitMode"
						:is-crop-mode="isCropMode"
						@toggle-playback="togglePlayback"
						@toggle-trim-mode="toggleTrimMode"
						@update:selected-ratio="onAspectRatioChange"
						@toggle-mute="toggleMute"
						@toggle-split-mode="toggleSplitMode"
						@update:isCropMode="isCropMode = $event"
						@captureScreenshot="handleCaptureScreenshot"
						class="mt-4"
					/>
				</div>
			</div>

			<div class="flex-shrink-0">
				<TimelineComponent
					:duration="videoDuration"
					:current-time="currentTime"
					:segments="segments"
					:is-split-mode="isSplitMode"
					@timeUpdate="handleTimeUpdate"
					@previewTimeUpdate="handlePreviewTimeUpdate"
					@segmentsReordered="handleSegmentsReordered"
					@splitSegment="handleSegmentSplit"
					ref="timelineRef"
				/>
			</div>
		</div>
	</div>
</template>

<script setup>
import { ref, onMounted, onUnmounted, computed, watch } from "vue";
import MediaPlayer from "~/components/MediaPlayer.vue";
import MediaPlayerControls from "~/components/MediaPlayerControls.vue";
import MediaPlayerSettings from "~/components/MediaPlayerSettings.vue";
import TimelineComponent from "~/components/TimelineComponent.vue";

const { updateCameraSettings } = usePlayerSettings();

// IPC event isimlerini al
const IPC_EVENTS = window.electron?.ipcRenderer?.IPC_EVENTS || {};

// Yardımcı fonksiyonlar
const generateId = () => {
	return "id-" + Math.random().toString(36).substr(2, 9);
};

const electron = window.electron;
const mediaPlayerRef = ref(null);
const videoUrl = ref("");
const audioUrl = ref("");
const cameraUrl = ref("");
const videoDuration = ref(0);
const currentTime = ref(0);
const currentVideoTime = ref(0);
const videoType = ref("video/mp4");
const audioType = ref("audio/webm");
const cameraType = ref("video/webm");
const videoBlob = ref(null);
const audioBlob = ref(null);
const cameraBlob = ref(null);
const isPlaying = ref(false);
const isTrimMode = ref(false);
const selectedRatio = ref("");
const selectedArea = ref(null);
const isMuted = ref(false);
const isSplitMode = ref(false);
const isCropMode = ref(false);

// Video boyutları
const videoSize = ref({
	width: 1920,
	height: 1080,
});

// Video boyutları için computed değerler
const videoWidth = computed(() => videoSize.value?.width || 1920);
const videoHeight = computed(() => videoSize.value?.height || 1080);

// Segment state'i
const segments = ref([
	{
		id: generateId(),
		startTime: 0,
		endTime: 0,
		startPosition: "0%",
		width: "100%",
		type: "video",
		layer: 0,
		selected: false,
		locked: false,
	},
]);

// Kırpma ve pozisyon state'leri
const cropState = ref({
	position: { x: 0, y: 0 },
	scale: 1,
	cropArea: { x: 0, y: 0, width: 0, height: 0 },
	containerSize: { width: 0, height: 0 },
	videoSize: { width: 0, height: 0 },
	aspectRatio: "",
});

// Video ve ses dosyalarını yükle
const loadMedia = async (filePath, type = "video") => {
	try {
		console.log(`[editor.vue] ${type} yükleniyor:`, filePath);

		const base64Data = await electron?.ipcRenderer.invoke(
			IPC_EVENTS.READ_VIDEO_FILE,
			filePath
		);

		if (!base64Data) {
			console.error(`[editor.vue] ${type} dosyası okunamadı:`, filePath);
			throw new Error(`${type} dosyası okunamadı`);
		}

		const extension = filePath.split(".").pop()?.toLowerCase();
		const mimeType =
			type === "video"
				? extension === "webm"
					? "video/webm"
					: "video/mp4"
				: type === "camera"
				? "video/webm"
				: extension === "webm"
				? "audio/webm"
				: "audio/mp4";

		console.log(`[editor.vue] ${type} MIME type:`, mimeType);

		const byteCharacters = atob(base64Data);
		const byteNumbers = new Array(byteCharacters.length);
		for (let i = 0; i < byteCharacters.length; i++) {
			byteNumbers[i] = byteCharacters.charCodeAt(i);
		}
		const byteArray = new Uint8Array(byteNumbers);
		const blob = new Blob([byteArray], { type: mimeType });

		console.log(`[editor.vue] ${type} blob created, size:`, blob.size);

		if (type === "video") {
			if (videoBlob.value) URL.revokeObjectURL(videoBlob.value);
			videoBlob.value = URL.createObjectURL(blob);
			videoUrl.value = videoBlob.value;
			videoType.value = mimeType;
		} else if (type === "camera") {
			if (cameraBlob.value) URL.revokeObjectURL(cameraBlob.value);
			cameraBlob.value = URL.createObjectURL(blob);
			cameraUrl.value = cameraBlob.value;
			cameraType.value = mimeType;
		} else {
			if (audioBlob.value) URL.revokeObjectURL(audioBlob.value);
			audioBlob.value = URL.createObjectURL(blob);
			audioUrl.value = audioBlob.value;
			audioType.value = mimeType;
		}

		console.log(`[editor.vue] ${type} yüklendi:`, {
			url:
				type === "video"
					? videoUrl.value
					: type === "camera"
					? cameraUrl.value
					: audioUrl.value,
			type:
				type === "video"
					? videoType.value
					: type === "camera"
					? cameraType.value
					: audioType.value,
			size: blob.size,
			mimeType,
		});
	} catch (error) {
		console.error(`[editor.vue] ${type} yükleme hatası:`, error);
		electron?.ipcRenderer.send(IPC_EVENTS.EDITOR_LOAD_ERROR, error.message);
	}
};

// Oynatma/durdurma kontrolü
const togglePlayback = () => {
	isPlaying.value = !isPlaying.value;
};

// Video yüklendiğinde
const onVideoLoaded = (data) => {
	try {
		console.log("[editor.vue] Video yüklendi, gelen data:", data);

		// Video bilgilerini kaydet
		if (data && typeof data.duration === "number") {
			videoDuration.value = Math.max(0, data.duration);
			videoSize.value = {
				width: data.width || 1920,
				height: data.height || 1080,
			};

			// İlk segment'i oluştur veya güncelle
			if (segments.value.length === 0) {
				segments.value = [
					{
						id: generateId(),
						startTime: 0,
						endTime: videoDuration.value,
						start: 0,
						end: videoDuration.value,
						startPosition: "0%",
						width: "100%",
						type: "video",
						layer: 0,
						selected: false,
						locked: false,
					},
				];
			} else {
				segments.value[0] = {
					...segments.value[0],
					startTime: 0,
					endTime: videoDuration.value,
					start: 0,
					end: videoDuration.value,
				};
			}

			console.log("[editor.vue] Segment güncellendi:", {
				duration: videoDuration.value,
				segment: segments.value[0],
			});

			// Segment pozisyonlarını güncelle
			updateSegments();
		} else {
			console.warn("[editor.vue] Video süresi geçersiz:", data);
		}
	} catch (error) {
		console.error("[editor.vue] Video yükleme hatası:", error);
	}
};

// Video bittiğinde
const onVideoEnded = () => {
	isPlaying.value = false;
};

// Video düzenleme başlatma
const startEditing = (videoData) => {
	console.log("[editor.vue] Düzenleme başlatılıyor:", videoData);
	videoUrl.value = videoData.url;
};

// Video kaydetme
const saveVideo = async () => {
	try {
		const filePath = await electron?.ipcRenderer.invoke("SHOW_SAVE_DIALOG", {
			title: "Videoyu Kaydet",
			defaultPath: `video_${Date.now()}.mp4`,
			filters: [{ name: "Video", extensions: ["mp4"] }],
		});

		if (filePath) {
			const sourceCanvas = mediaPlayerRef.value?.getCanvas();
			if (!sourceCanvas) {
				throw new Error("Canvas bulunamadı");
			}

			// Kaydedilecek canvas'ın çözünürlüğünü artır
			// sourceCanvas.width = targetWidth;
			// sourceCanvas.height = targetHeight;

			// Kayıt durumu mesajı göster
			const loadingMessage = document.createElement("div");
			loadingMessage.className =
				"fixed inset-0 flex items-center text-center justify-center bg-black bg-opacity-50 z-50";
			loadingMessage.innerHTML = `
                <div class="bg-black/80 p-8 rounded-xl shadow-3xl text-white">
                    <p class="text-lg font-bold">Video kaydediliyor...</p>
                    <p class="text-sm mt-2">Lütfen bekleyin...</p>
                </div>
            `;
			document.body.appendChild(loadingMessage);

			return new Promise(async (resolve, reject) => {
				try {
					const stream = sourceCanvas.captureStream(60); // 60 FPS

					// Get the audio from the video element directly
					const videoElement = mediaPlayerRef.value.getVideoElement();
					const audioContext = new AudioContext();
					const source = audioContext.createMediaElementSource(videoElement);
					const destination = audioContext.createMediaStreamDestination();
					source.connect(destination);
					source.connect(audioContext.destination); // To continue hearing the audio

					// Add the audio track to our stream
					destination.stream
						.getAudioTracks()
						.forEach((track) => stream.addTrack(track));

					const mediaRecorder = new MediaRecorder(stream, {
						mimeType: "video/webm",
						videoBitsPerSecond: 5000000, // 5 Mbps
					});

					const chunks = [];
					mediaRecorder.ondataavailable = (e) => {
						if (e.data.size > 0) {
							chunks.push(e.data);
						}
					};

					let startTime = null;
					let lastFrameTime = 0;
					const frameInterval = 1000 / 60; // 60 FPS için

					// Frame çizim fonksiyonu
					const renderFrame = async (currentTime) => {
						if (!startTime) startTime = currentTime;
						const elapsed = currentTime - startTime;

						if (currentTime - lastFrameTime >= frameInterval) {
							lastFrameTime = currentTime;

							const videoTime = elapsed / 1000;
							if (videoTime >= videoDuration.value) {
								mediaRecorder.stop();
								return;
							}

							await mediaPlayerRef.value.play();
						}

						requestAnimationFrame(renderFrame);
					};

					mediaRecorder.onstop = async () => {
						try {
							await mediaPlayerRef.value.seek(0);
							const webmBlob = new Blob(chunks, { type: "video/webm" });
							const arrayBuffer = await webmBlob.arrayBuffer();
							const base64Data = btoa(
								new Uint8Array(arrayBuffer).reduce(
									(data, byte) => data + String.fromCharCode(byte),
									""
								)
							);

							const result = await electron?.ipcRenderer.invoke(
								"SAVE_VIDEO",
								`data:video/webm;base64,${base64Data}`,
								filePath
							);

							if (result?.success) {
								console.log("Video başarıyla kaydedildi");
							} else {
								throw new Error(result?.error || "Video kaydedilemedi");
							}

							if (loadingMessage.parentNode) {
								document.body.removeChild(loadingMessage);
							}

							resolve(result);
						} catch (error) {
							console.error("Kayıt sonlandırma hatası:", error);
							reject(error);
						}
					};

					mediaRecorder.start();

					await mediaPlayerRef.value.seek(0);
					requestAnimationFrame(renderFrame);
				} catch (error) {
					console.error("Kayıt başlatma hatası:", error);
					if (loadingMessage.parentNode) {
						document.body.removeChild(loadingMessage);
					}
					reject(error);
				}
			});
		}
	} catch (error) {
		console.error("Video kaydedilirken hata:", error);
		alert("Videoyu kaydederken bir hata oluştu: " + error.message);
	}
};

// Değişiklikleri iptal et
const discardChanges = () => {
	if (confirm("Değişiklikleri iptal etmek istediğinize emin misiniz ?")) {
		closeWindow();
	}
};

// Pencereyi kapat
const closeWindow = () => {
	electron?.ipcRenderer.send("CLOSE_EDITOR_WINDOW");
};

// Yeni kayıt başlat
const startNewRecording = () => {
	if (confirm("Yeni kayıt başlatmak istediğinize emin misiniz?")) {
		electron?.ipcRenderer.send("RESET_FOR_NEW_RECORDING");
		closeWindow();
	}
};

// Video zamanı güncellendiğinde
const onTimeUpdate = (time) => {
	if (!isNaN(time)) {
		currentTime.value = time;
		currentVideoTime.value = time;
	}
};

// Timeline'dan gelen zaman güncellemesi
const handleTimeUpdate = (time) => {
	if (!isNaN(time)) {
		currentTime.value = time;
		if (mediaPlayerRef.value) {
			mediaPlayerRef.value.seek(time);
		}
	}
};

// Kesme modunu aç/kapa
const toggleTrimMode = () => {
	isTrimMode.value = !isTrimMode.value;
};

// Segment güncellemelerini işle
const onSegmentUpdate = ({ type, segments }) => {
	console.log(`[editor.vue] ${type} segmentleri güncellendi:`, segments);
	// Burada segmentleri işleyebilir ve videoyu/sesi buna göre düzenleyebilirsiniz
};

// Kırpma değişikliklerini işle
const onCropChange = (cropArea) => {
	try {
		if (!cropArea) {
			selectedArea.value = null;
			// Seçilen alanı sıfırla
			window.electron.ipcRenderer.send("UPDATE_SELECTED_AREA", null);
			console.log("[editor.vue] Kırpma alanı sıfırlandı");
			return;
		}

		// cropArea'dan sadece gerekli değerleri al ve yeni bir obje oluştur
		const safeArea = {
			x: typeof cropArea.x === "number" ? Math.round(cropArea.x) : 0,
			y: typeof cropArea.y === "number" ? Math.round(cropArea.y) : 0,
			width:
				typeof cropArea.width === "number"
					? Math.round(cropArea.width)
					: videoWidth.value,
			height:
				typeof cropArea.height === "number"
					? Math.round(cropArea.height)
					: videoHeight.value,
			devicePixelRatio: window.devicePixelRatio || 1,
		};

		// Değerlerin geçerliliğini kontrol et
		if (safeArea.width <= 0 || safeArea.height <= 0) {
			console.warn("[editor.vue] Geçersiz kırpma boyutları:", safeArea);
			return;
		}

		// Video boyutlarını aşmadığından emin ol
		safeArea.width = Math.min(safeArea.width, videoWidth.value);
		safeArea.height = Math.min(safeArea.height, videoHeight.value);
		safeArea.x = Math.min(
			Math.max(0, safeArea.x),
			videoWidth.value - safeArea.width
		);
		safeArea.y = Math.min(
			Math.max(0, safeArea.y),
			videoHeight.value - safeArea.height
		);

		console.log("[editor.vue] Kırpma alanı hazırlandı:", safeArea);

		// State'i güncelle
		selectedArea.value = safeArea;

		// Main process'e gönder
		window.electron.ipcRenderer.send("UPDATE_SELECTED_AREA", safeArea);
		console.log("[editor.vue] Kırpma alanı main process'e gönderildi");
	} catch (error) {
		console.error("[editor.vue] Kırpma alanı güncellenirken hata:", error);
	}
};

// Aspect ratio değişikliğini işle
const onAspectRatioChange = (ratio) => {
	try {
		if (mediaPlayerRef.value) {
			selectedRatio.value = ratio;
			mediaPlayerRef.value.updateAspectRatio(ratio);

			// Kırpma durumunu güncelle
			const cropData = mediaPlayerRef.value.getCropData();
			if (cropData) {
				console.log(
					"[editor.vue] Yeni aspect ratio için kırpma verisi:",
					cropData
				);
				onCropChange(cropData);
			}
		}
	} catch (error) {
		console.error("[editor.vue] Aspect ratio güncellenirken hata:", error);
	}
};

// Timeline segment'lerini güncelle
const updateSegments = () => {
	if (!segments.value?.length) return;

	segments.value = segments.value.map((segment) => {
		const start = segment.start || segment.startTime || 0;
		const end = segment.end || segment.endTime || videoDuration.value;
		const duration = videoDuration.value || 1;

		return {
			...segment,
			start,
			end,
			startTime: start,
			endTime: end,
			startPosition: `${(start / duration) * 100}%`,
			width: `${((end - start) / duration) * 100}%`,
		};
	});
};

// Ses kontrolü
const toggleMute = () => {
	isMuted.value = !isMuted.value;
};

// Segment bölme işlemi
const handleSegmentSplit = ({ index, segments: newSegments, splitTime }) => {
	// Orijinal segmenti kaldır ve yerine yeni segmentleri ekle
	const updatedSegments = [...segments.value];
	updatedSegments.splice(index, 1, ...newSegments);
	segments.value = updatedSegments;

	// Timeline'ı güncelle
	updateSegments();
};

// Toggle split mode
const toggleSplitMode = () => {
	isSplitMode.value = !isSplitMode.value;
};

// Segment yönetimi
const handleSegmentsReordered = (newSegments) => {
	// Yeni segment sıralamasını uygula
	segments.value = newSegments;

	// MediaPlayer'ı güncelle
	if (mediaPlayerRef.value) {
		// Eğer video oynatılıyorsa, mevcut segmentin başlangıç zamanına git
		if (isPlaying.value) {
			const currentSegment = newSegments.find(
				(segment) =>
					currentTime.value >= segment.start && currentTime.value <= segment.end
			);
			if (currentSegment) {
				mediaPlayerRef.value.seek(currentSegment.start);
			}
		}
	}
};

// Video URL'lerini computed olarak yönet
const videoSrc = computed(() => videoUrl.value || "");

// Preview time state'i
const previewTime = ref(null);

// Preview time güncelleme
const handlePreviewTimeUpdate = (time) => {
	previewTime.value = time;
};

let mousePositions = ref([]);

onMounted(async () => {
	// Cursor verilerini yükle
	if (electron.mediaStateManager) {
		const cursorData = await electron.mediaStateManager.loadCursorData();
		mousePositions.value = cursorData;
	}

	let editorSettings = await electron?.ipcRenderer.invoke(
		IPC_EVENTS.GET_EDITOR_SETTINGS
	);

	console.log("Editor settings:", editorSettings);
	let isCameraFollowMouse = editorSettings.camera.followMouse;

	updateCameraSettings({
		followMouse: isCameraFollowMouse,
	});

	// Mevcut kaydedicileri temizle
	if (mediaRecorder.value) {
		mediaRecorder.value = null;
	}

	// Ekran boyutlarını alıp saklayalım
	if (window?.electron?.screen) {
		const displaySize = await window.electron.screen.getPrimaryDisplay();
		if (displaySize) {
			screenWidth.value = displaySize.bounds.width;
			screenHeight.value = displaySize.bounds.height;
		}
	}

	// Medya dosyalarını yenileştirilmiş loadMediaFromState() fonksiyonu ile yükle
	await loadMediaFromState();

	// ... rest of the existing code ...
});

onUnmounted(() => {
	// Clean up listener
	electron.ipcRenderer.removeAllListeners(
		electron.ipcRenderer.IPC_EVENTS.MOUSE_POSITION_UPDATED
	);
});

onMounted(async () => {
	try {
		// İlk olarak mevcut media state'i al
		const mediaState = await electron?.ipcRenderer.invoke(
			IPC_EVENTS.GET_MEDIA_STATE
		);
		console.log("[editor.vue] Başlangıç media state:", mediaState);

		if (mediaState) {
			if (mediaState.videoPath) {
				console.log(
					"[editor.vue] Video dosyası yükleniyor:",
					mediaState.videoPath
				);
				await loadMedia(mediaState.videoPath, "video");
			} else {
				console.error("[editor.vue] Video dosyası bulunamadı");
				electron?.ipcRenderer.send(
					IPC_EVENTS.EDITOR_LOAD_ERROR,
					"Video dosyası bulunamadı"
				);
				return;
			}

			if (mediaState.cameraPath) {
				console.log(
					"[editor.vue] Kamera dosyası yükleniyor:",
					mediaState.cameraPath
				);
				await loadMedia(mediaState.cameraPath, "camera");
			}

			if (mediaState.audioPath) {
				console.log(
					"[editor.vue] Ses dosyası yükleniyor:",
					mediaState.audioPath
				);
				await loadMedia(mediaState.audioPath, "audio");
			}
		}

		// Media state güncellemelerini dinle
		electron?.ipcRenderer.on(IPC_EVENTS.MEDIA_STATE_UPDATE, async (state) => {
			console.log("[editor.vue] Media state güncellendi:", state);
			if (state.videoPath && state.videoPath !== videoUrl.value) {
				await loadMedia(state.videoPath, "video");
			}
			if (state.cameraPath && state.cameraPath !== cameraUrl.value) {
				await loadMedia(state.cameraPath, "camera");
			}
			if (state.audioPath && state.audioPath !== audioUrl.value) {
				await loadMedia(state.audioPath, "audio");
			}
		});

		// Processing complete event'ini dinle
		electron?.ipcRenderer.on(IPC_EVENTS.PROCESSING_COMPLETE, async (paths) => {
			console.log("[editor.vue] Processing complete:", paths);
			if (paths.videoPath) await loadMedia(paths.videoPath, "video");
			if (paths.cameraPath) await loadMedia(paths.cameraPath, "camera");
			if (paths.audioPath) await loadMedia(paths.audioPath, "audio");
		});

		// Media paths event'ini dinle
		electron?.ipcRenderer.on(IPC_EVENTS.MEDIA_PATHS, async (paths) => {
			console.log("[editor.vue] Media paths güncellendi:", paths);
			if (paths.videoPath) await loadMedia(paths.videoPath, "video");
			if (paths.cameraPath) await loadMedia(paths.cameraPath, "camera");
			if (paths.audioPath) await loadMedia(paths.audioPath, "audio");
		});
	} catch (error) {
		console.error("[editor.vue] Başlangıç hatası:", error);
		electron?.ipcRenderer.send(IPC_EVENTS.EDITOR_LOAD_ERROR, error.message);
	}
});

onUnmounted(() => {
	if (videoBlob.value) URL.revokeObjectURL(videoBlob.value);
	if (cameraBlob.value) URL.revokeObjectURL(cameraBlob.value);
	if (audioBlob.value) URL.revokeObjectURL(audioBlob.value);

	if (window.electron) {
		window.electron.ipcRenderer.removeAllListeners("MEDIA_PATHS");
		window.electron.ipcRenderer.removeAllListeners("START_EDITING");
		window.electron.ipcRenderer.removeAllListeners("PROCESSING_COMPLETE");
	}
});

// Mouse ayarları
const mouseSize = ref(42);

// Mouse size değişikliğini izle
watch(
	mouseSize,
	(newSize) => {
		console.log("[editor.vue] Mouse size güncellendi:", newSize);
	},
	{ immediate: true }
);

// Sürükleme durumu için ref
const isDragging = ref(false);
const initialMousePosition = ref({ x: 0, y: 0 });

// Pencere sürükleme fonksiyonları
const startDrag = (event) => {
	isDragging.value = true;
	initialMousePosition.value = {
		x: event.screenX,
		y: event.screenY,
	};

	// Global event listener'ları ekle
	window.addEventListener("mousemove", handleGlobalMouseMove);
	window.addEventListener("mouseup", handleGlobalMouseUp);

	electron?.ipcRenderer.send("START_WINDOW_DRAG", {
		x: event.screenX,
		y: event.screenY,
	});
};

const handleGlobalMouseMove = (event) => {
	if (!isDragging.value) return;

	electron?.ipcRenderer.send("WINDOW_DRAGGING", {
		x: event.screenX,
		y: event.screenY,
	});
};

const handleGlobalMouseUp = () => {
	if (!isDragging.value) return;

	isDragging.value = false;
	// Global event listener'ları kaldır
	window.removeEventListener("mousemove", handleGlobalMouseMove);
	window.removeEventListener("mouseup", handleGlobalMouseUp);

	electron?.ipcRenderer.send("END_WINDOW_DRAG");
};

// Event listener'ları temizle
onUnmounted(() => {
	window.removeEventListener("mousemove", handleGlobalMouseMove);
	window.removeEventListener("mouseup", handleGlobalMouseUp);
});

// Screenshot alma fonksiyonu
const handleCaptureScreenshot = async () => {
	if (!mediaPlayerRef.value) return;

	try {
		// Canvas'tan görüntüyü al
		const imageData = mediaPlayerRef.value.captureFrame();
		if (!imageData) {
			console.error("Ekran görüntüsü alınamadı");
			return;
		}

		// Electron IPC ile görüntüyü kaydet
		const result = await electron?.ipcRenderer.invoke("SHOW_SAVE_DIALOG", {
			title: "Ekran Görüntüsünü Kaydet",
			defaultPath: `screenshot_${Date.now()}.png`,
			filters: [{ name: "Görüntü", extensions: ["png", "jpg"] }],
		});

		if (result) {
			// Base64 formatındaki görüntüyü kaydet
			const saveResult = await electron?.ipcRenderer.invoke(
				IPC_EVENTS.SAVE_SCREENSHOT,
				imageData,
				result
			);

			if (saveResult?.success) {
				console.log("Ekran görüntüsü başarıyla kaydedildi:", result);
			} else {
				console.error("Ekran görüntüsü kaydedilemedi:", saveResult?.error);
			}
		}
	} catch (error) {
		console.error("Ekran görüntüsü alınırken hata oluştu:", error);
	}
};

// Medya dosyalarını yükleme fonksiyonu
async function loadMediaFromState() {
	try {
		if (electron?.ipcRenderer) {
			// Medya yollarını al
			const mediaState = await electron.ipcRenderer.invoke("GET_MEDIA_STATE");

			console.log("Medya durumu alındı:", mediaState);

			// Video dosyası kontrolü
			if (mediaState.videoPath) {
				console.log("Video dosyası alındı:", mediaState.videoPath);
				await loadMedia(mediaState.videoPath, "video");
			} else {
				console.warn("[editor.vue] Video path not found in media state");
			}

			// Audio dosyası kontrolü
			if (mediaState.audioPath) {
				console.log("Ses dosyası alındı:", mediaState.audioPath);
				// Eğer ses dosyası video ile aynı dosya ise, ayrıca yükleme yapma
				if (mediaState.audioPath === mediaState.videoPath) {
					console.log("Ses ve video aynı dosyada, ayrıca yüklenmeyecek");
					// Video'nun ses kanalını kullan
					audioType.value = videoType.value;
					console.log(
						"[editor.vue] Audio type set to video type:",
						audioType.value
					);

					// Since audio is in the video file, make sure we're not muting it
					isMuted.value = false;
					console.log(
						"[editor.vue] Unmuting audio since it's in the video file"
					);
				} else {
					// Farklı bir ses dosyası ise ayrıca yükle
					console.log("[editor.vue] Loading separate audio file");
					await loadMedia(mediaState.audioPath, "audio");
				}
			} else {
				console.warn("[editor.vue] Audio path not found in media state");
			}
		} else {
			console.error("[editor.vue] Electron IPC not available");
		}
	} catch (error) {
		console.error("Medya durumu yükleme hatası:", error);
		electron?.ipcRenderer.send(IPC_EVENTS.EDITOR_LOAD_ERROR, error.message);
	}
}
</script>
